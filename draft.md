# TODOs

- [ ] Add references to the binaries in dataset.

## Intro / Background

Binary code similarity detection (BCSD) becomes more important as the modularity and rate of production of software grows.
Modern software is almost never written from scratch, and is becoming increasingly reliant on external libraries.
For reverse engineers, reducing the amount of repetitive assembly functions to analyze is important,
    as it allows them to be more efficient and focus on the custom parts of a binary.
If a vulnerability is found in a library, it is important to be able to quickly identify if an unknown or proprietary binary
    is using the vulnerable library, so that its impact can be mitigated.
Other applications of BCSD include license compliance and plagiarism detection.

### Contributions

We develop an elementary approach to BCSD purely based on the recent advancements in large language models (LLM).

Instead of generating a numerical feature vector for a given assembly function, we generate a feature set containing
human readable elements.

TBD: how does this method compare to SOTA?

Advantages:

TBD: We show that this method scales with the capabilities of large language models. 
    (This is great since significant investments & research goes to LLMs, blah blah)

Humans can verify the feature set generated by our method.
    (In an ideal world, we would not need human verification. Current methods are not perfect so human verif is still needed.
     Our method eases this process and can more easily be debugged.)

## Related Work

### Static Analysis

Traditional methods make use of static analysis to detect clone assembly routines. With these methods, a trade-off has
to be made between the robustness to obfuscation and architecture differences, and the performance of the algorithm. [1]
Control flow graph analysis and comparison [ref] is known to be very robust to syntactic differences, but involves resource-intensive
computations. Simpler algorithms that use heuristics such as instruction frequency or longest-common-subsequence (LCS) [ref] are more
efficient but tend to fixate on the syntactic elements rather than the semantics.

### Dynamic Analysis

Dynamic analysis consists of analyzing the features of a binary or code fragment by monitoring its runtime behavior. For BCSD
this method is compute intensive and requires a featureful emulator, but completely sidesteps the syntactic aspects of binary code
and solely analyzes the semantics. [2] As such, this method is a high-cost but powerful works very well for cross-architecture, cross-optimization and cross-obfuscation analysis.

### Machine Learning Methods

The surge of interest and applications for machine learning in recent years has also affected BCSD.
Current state-of-the-art methods use natural language processing (NLP) to achieve their results [refs].
Notably, recent machine learning approaches try to incorporate the transformer architecture into BCSD tasks [refs].

- Talk about BERT based models (PalmTree, SAFE, etc.)

Others make use of widely available LLMs either during training as data annotation [ref] (CLAP)

## Methodology

### Dataset

The dataset is composed of 7 binaries: busybox, coreutils, curl, image-magick, openssl, putty, and sqlite3.
All were compiled using gcc for the following platforms: x86_64, x86_32, arm, mips, powerpc.
For each binary and platform, binary objects were generated for each optimization level (O0 to O3).
Stripped all debug symbols except for function names, so as to be able to match functions across binaries.
In total, yeilds 140 different binaries to analyze.
The binaries were dissassembled using IDA Pro, yielding 383_658 assembly routines.

### Model

We evaluate two models on our dataset.
Qwen2.5-Coder [ref] with sizes 0.5B to 7B, and Gemma3 [ref] with sizes 1.5B and 3B.

# Refs

1. [A Survey of Binary Code Similarity Detection Techniques](https://www.mdpi.com/2079-9292/13/9/1715)
2. [Binary Code Similiarity Detection](https://ieeexplore.ieee.org/document/9678518)