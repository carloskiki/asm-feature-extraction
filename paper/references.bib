@article{BCSDsurvey,
  author         = {Ruan, Liting and Xu, Qizhen and Zhu, Shunzhi and Huang, Xujing and Lin, Xinyang},
  title          = {A Survey of Binary Code Similarity Detection Techniques},
  journal        = {Electronics},
  volume         = {13},
  year           = {2024},
  number         = {9},
  article-number = {1715},
  url            = {https://www.mdpi.com/2079-9292/13/9/1715},
  issn           = {2079-9292},
  abstract       = {Binary Code Similarity Detection is a method that involves comparing two or more binary code segments to identify their similarities and differences. This technique plays a crucial role in areas such as software security, vulnerability detection, and software composition analysis. With the extensive use of binary code in software development and system optimization, binary code similarity detection has become an important area of research. Traditional methods of source code similarity detection face challenges when dealing with the unreadable and complex nature of binary code, necessitating specialized techniques and algorithms. This review compares and summarizes various techniques and methods of binary code similarity detection, highlighting their strengths and limitations in handling different characteristics of binary code. Additionally, the article suggests potential future research directions. As research and innovation in this technology continue to advance, binary code similarity detection is expected to play an increasingly significant role in fields like software security.},
  doi            = {10.3390/electronics13091715}
}

@inproceedings{BCSD,
  author    = {Liu, Zian},
  booktitle = {2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  title     = {Binary Code Similarity Detection},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {1056-1060},
  keywords  = {Prototypes;Binary codes;Writing;Explosions;Software engineering;Binary code;code analysis;symbolic execution},
  doi       = {10.1109/ASE51524.2021.9678518}
}

@inproceedings{graph-bug-search,
  author    = {Feng, Qian and Zhou, Rundong and Xu, Chengcheng and Cheng, Yao and Testa, Brian and Yin, Heng},
  title     = {Scalable Graph-based Bug Search for Firmware Images},
  year      = {2016},
  isbn      = {9781450341394},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2976749.2978370},
  doi       = {10.1145/2976749.2978370},
  abstract  = {Because of rampant security breaches in IoT devices, searching vulnerabilities in massive IoT ecosystems is more crucial than ever. Recent studies have demonstrated that control-flow graph (CFG) based bug search techniques can be effective and accurate in IoT devices across different architectures. However, these CFG-based bug search approaches are far from being scalable to handle an enormous amount of IoT devices in the wild, due to their expensive graph matching overhead. Inspired by rich experience in image and video search, we propose a new bug search scheme which addresses the scalability challenge in existing cross-platform bug search techniques and further improves search accuracy. Unlike existing techniques that directly conduct searches based upon raw features (CFGs) from the binary code, we convert the CFGs into high-level numeric feature vectors. Compared with the CFG feature, high-level numeric feature vectors are more robust to code variation across different architectures, and can easily achieve realtime search by using state-of-the-art hashing techniques. We have implemented a bug search engine, Genius, and compared it with state-of-art bug search approaches. Experimental results show that Genius outperforms baseline approaches for various query loads in terms of speed and accuracy. We also evaluated Genius on a real-world dataset of 33,045 devices which was collected from public sources and our system. The experiment showed that Genius can finish a search within 1 second on average when performed over 8,126 firmware images of 420,558,702 functions. By only looking at the top 50 candidates in the search result, we found 38 potentially vulnerable firmware images across 5 vendors, and confirmed 23 of them by our manual analysis. We also found that it took only 0.1 seconds on average to finish searching for all 154 vulnerabilities in two latest commercial firmware images from D-LINK. 103 of them are potentially vulnerable in these images, and 16 of them were confirmed.},
  booktitle = {Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {480-491},
  numpages  = {12},
  keywords  = {machine learning, graph encoding, firmware security},
  location  = {Vienna, Austria},
  series    = {CCS '16}
}

@inproceedings{BinDiff,
  title  = {Graph-based comparison of Executable Objects},
  author = {Thomas Dullien},
  year   = {2005},
  url    = {https://api.semanticscholar.org/CorpusID:2001486}
}

@inproceedings{clones.net,
  author    = {Al-Omari, Farouq and Keivanloo, Iman and Roy, Chanchal K. and Rilling, Juergen},
  booktitle = {2012 19th Working Conference on Reverse Engineering},
  title     = {Detecting Clones Across Microsoft .NET Programming Languages},
  year      = {2012},
  volume    = {},
  number    = {},
  pages     = {405-414},
  keywords  = {Cloning;Filtering;Computer languages;Software;Filtering algorithms;Noise;Context;cross-language clone detection;intermediate language;binary;multi-language;similarity component},
  doi       = {10.1109/WCRE.2012.50}
}

@inproceedings{op-seq,
  author    = {Santos, Igor and Brezo, Felix and Nieves, Javier and Penya, Yoseba K. and Sanz, Borja and Laorden, Carlos and Bringas, Pablo G.},
  title     = {Idea: opcode-sequence-based malware detection},
  year      = {2010},
  isbn      = {3642117465},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  url       = {https://doi.org/10.1007/978-3-642-11747-3_3},
  doi       = {10.1007/978-3-642-11747-3_3},
  abstract  = {Malware is every malicious code that has the potential to harm any computer or network. The amount of malware is increasing faster every year and poses a serious security threat. Hence, malware detection has become a critical topic in computer security. Currently, signature-based detection is the most extended method within commercial antivirus. Although this method is still used on most popular commercial computer antivirus software, it can only achieve detection once the virus has already caused damage and it is registered. Therefore, it fails to detect new variations of known malware. In this paper, we propose a new method to detect variants of known malware families. This method is based on the frequency of appearance of opcode sequences. Furthermore, we describe a method to mine the relevance of each opcode and, thereby, weigh each opcode sequence frequency. We show that this method provides an effective way to detect variants of known malware families.},
  booktitle = {Proceedings of the Second International Conference on Engineering Secure Software and Systems},
  pages     = {35–43},
  numpages  = {9},
  keywords  = {computer security, machine learning, malware detection},
  location  = {Pisa, Italy},
  series    = {ESSoS'10}
}

@inproceedings{sem-hash,
  author    = {Jin, Wesley and Chaki, Sagar and Cohen, Cory and Gurfinkel, Arie and Havrilla, Jeffrey and Hines, Charles and Narasimhan, Priya},
  booktitle = {2012 11th International Conference on Machine Learning and Applications},
  title     = {Binary Function Clustering Using Semantic Hashes},
  year      = {2012},
  volume    = {1},
  number    = {},
  pages     = {386-391},
  keywords  = {Semantics;Malware;Registers;Benchmark testing;Concrete;Feature extraction;Catalogs;semantic comparison;malware detection;clustering;reverse engineering;binary static analysis},
  doi       = {10.1109/ICMLA.2012.70}
}

@misc{c-o-t,
  title         = {Chain-of-Thought Prompting Elicits Reasoning in Large Language Models},
  author        = {Jason Wei and Xuezhi Wang and Dale Schuurmans and Maarten Bosma and Brian Ichter and Fei Xia and Ed Chi and Quoc Le and Denny Zhou},
  year          = {2023},
  eprint        = {2201.11903},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/2201.11903}
}

@misc{reasoning,
  title         = {Large Language Models are Zero-Shot Reasoners},
  author        = {Takeshi Kojima and Shixiang Shane Gu and Machel Reid and Yutaka Matsuo and Yusuke Iwasawa},
  year          = {2023},
  eprint        = {2205.11916},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/2205.11916}
}

@misc{thinking-llm,
  title         = {Thinking LLMs: General Instruction Following with Thought Generation},
  author        = {Tianhao Wu and Janice Lan and Weizhe Yuan and Jiantao Jiao and Jason Weston and Sainbayar Sukhbaatar},
  year          = {2024},
  eprint        = {2410.10630},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/2410.10630}
}

@misc{SAFE,
  title         = {SAFE: Self-Attentive Function Embeddings for Binary Similarity},
  author        = {Luca Massarelli and Giuseppe Antonio Di Luna and Fabio Petroni and Leonardo Querzoni and Roberto Baldoni},
  year          = {2019},
  eprint        = {1811.05296},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CR},
  url           = {https://arxiv.org/abs/1811.05296}
}

@misc{word2vec,
  title         = {Distributed Representations of Words and Phrases and their Compositionality},
  author        = {Tomas Mikolov and Ilya Sutskever and Kai Chen and Greg Corrado and Jeffrey Dean},
  year          = {2013},
  eprint        = {1310.4546},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/1310.4546}
}

@misc{SANN,
  title         = {A Structured Self-attentive Sentence Embedding},
  author        = {Zhouhan Lin and Minwei Feng and Cicero Nogueira dos Santos and Mo Yu and Bing Xiang and Bowen Zhou and Yoshua Bengio},
  year          = {2017},
  eprint        = {1703.03130},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/1703.03130}
}

@inproceedings{PalmTree,
  author    = {Li, Xuezixiang and Qu, Yu and Yin, Heng},
  title     = {PalmTree: Learning an Assembly Language Model for Instruction Embedding},
  year      = {2021},
  isbn      = {9781450384544},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3460120.3484587},
  doi       = {10.1145/3460120.3484587},
  abstract  = {Deep learning has demonstrated its strengths in numerous binary analysis tasks, including function boundary detection, binary code search, function prototype inference, value set analysis, etc. When applying deep learning to binary analysis tasks, we need to decide what input should be fed into the neural network model. More specifically, we need to answer how to represent an instruction in a fixed-length vector. The idea of automatically learning instruction representations is intriguing, but the existing schemes fail to capture the unique characteristics of disassembly. These schemes ignore the complex intra-instruction structures and mainly rely on control flow in which the contextual information is noisy and can be influenced by compiler optimizations. In this paper, we propose to pre-train an assembly language model called PalmTree for generating general-purpose instruction embeddings by conducting self-supervised training on large-scale unlabeled binary corpora. PalmTree utilizes three pre-training tasks to capture various characteristics of assembly language. These training tasks overcome the problems in existing schemes, thus can help to generate high-quality representations. We conduct both intrinsic and extrinsic evaluations, and compare PalmTree with other instruction embedding schemes. PalmTree has the best performance for intrinsic metrics, and outperforms the other instruction embedding schemes for all downstream tasks.},
  booktitle = {Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {3236–3251},
  numpages  = {16},
  keywords  = {binary analysis, deep learning, language model, representation learning},
  location  = {Virtual Event, Republic of Korea},
  series    = {CCS '21}
}

@misc{BERT,
  title         = {BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding},
  author        = {Jacob Devlin and Ming-Wei Chang and Kenton Lee and Kristina Toutanova},
  year          = {2019},
  eprint        = {1810.04805},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/1810.04805}
}

@article{OrderMatters,
  title        = {Order Matters: Semantic-Aware Neural Networks for Binary Code Similarity Detection},
  volume       = {34},
  url          = {https://ojs.aaai.org/index.php/AAAI/article/view/5466},
  doi          = {10.1609/aaai.v34i01.5466},
  abstractnote = {&lt;p&gt;Binary code similarity detection, whose goal is to detect similar binary functions without having access to the source code, is an essential task in computer security. Traditional methods usually use graph matching algorithms, which are slow and inaccurate. Recently, neural network-based approaches have made great achievements. A binary function is first represented as an control-flow graph (CFG) with manually selected block features, and then graph neural network (GNN) is adopted to compute the graph embedding. While these methods are effective and efficient, they could not capture enough semantic information of the binary code. In this paper we propose semantic-aware neural networks to extract the semantic information of the binary code. Specially, we use BERT to pre-train the binary code on one token-level task, one block-level task, and two graph-level tasks. Moreover, we find that the order of the CFG’s nodes is important for graph similarity detection, so we adopt convolutional neural network (CNN) on adjacency matrices to extract the order information. We conduct experiments on two tasks with four datasets. The results demonstrate that our method outperforms the state-of-art models.&lt;/p&gt;},
  number       = {01},
  journal      = {Proceedings of the AAAI Conference on Artificial Intelligence},
  author       = {Yu, Zeping and Cao, Rui and Tang, Qiyi and Nie, Sen and Huang, Junzhou and Wu, Shi},
  year         = {2020},
  month        = {Apr.},
  pages        = {1145-1152}
}

@inproceedings{Asm2Vec,
  author    = {Ding, Steven H. H. and Fung, Benjamin C. M. and Charland, Philippe},
  booktitle = {2019 IEEE Symposium on Security and Privacy (SP)},
  title     = {Asm2Vec: Boosting Static Representation Robustness for Binary Clone Search against Code Obfuscation and Compiler Optimization},
  year      = {2019},
  volume    = {},
  number    = {},
  pages     = {472-489},
  keywords  = {Cloning;Semantics;Search problems;Optimization;Software;Search engines;Syntactics;Binary-Code-Search;Vulnerability-Search;Static-Analysis;Representation-Learning},
  doi       = {10.1109/SP.2019.00003}
}

@misc{PV-DM,
  title         = {Distributed Representations of Sentences and Documents},
  author        = {Quoc V. Le and Tomas Mikolov},
  year          = {2014},
  eprint        = {1405.4053},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/1405.4053}
}

@inproceedings{CLAP,
  author    = {Wang, Hao and Gao, Zeyu and Zhang, Chao and Sha, Zihan and Sun, Mingyang and Zhou, Yuchen and Zhu, Wenyu and Sun, Wenju and Qiu, Han and Xiao, Xi},
  title     = {CLAP: Learning Transferable Binary Code Representations with Natural Language Supervision},
  year      = {2024},
  isbn      = {9798400706127},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3650212.3652145},
  doi       = {10.1145/3650212.3652145},
  abstract  = {Binary code representation learning has shown significant performance in binary analysis tasks. But existing solutions often have poor transferability, particularly in few-shot and zero-shot scenarios where few or no training samples are available for the tasks. To address this problem, we present CLAP (Contrastive Language-Assembly Pre-training), which employs natural language supervision to learn better representations of binary code (i.e., assembly code) and get better transferability. At the core, our approach boosts superior transfer learning capabilities by effectively aligning binary code with their semantics explanations (in natural language), resulting a model able to generate better embeddings for binary code. To enable this alignment training, we then propose an efficient dataset engine that could automatically generate a large and diverse dataset comprising of binary code and corresponding natural language explanations. We have generated 195 million pairs of binary code and explanations and trained a prototype of CLAP. The evaluations of CLAP across various downstream tasks in binary analysis all demonstrate exceptional performance. Notably, without any task-specific training, CLAP is often competitive with a fully supervised baseline, showing excellent transferability.},
  booktitle = {Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages     = {503–515},
  numpages  = {13},
  keywords  = {Binary Analysis, Deep Learning, Representation Learning},
  location  = {Vienna, Austria},
  series    = {ISSTA 2024}
}

@misc{RoBERTa,
  title         = {RoBERTa: A Robustly Optimized BERT Pretraining Approach},
  author        = {Yinhan Liu and Myle Ott and Naman Goyal and Jingfei Du and Mandar Joshi and Danqi Chen and Omer Levy and Mike Lewis and Luke Zettlemoyer and Veselin Stoyanov},
  year          = {2019},
  eprint        = {1907.11692},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/1907.11692}
}

@misc{ANN,
  title         = {Approximate Nearest Neighbor Search in High Dimensions},
  author        = {Alexandr Andoni and Piotr Indyk and Ilya Razenshteyn},
  year          = {2018},
  eprint        = {1806.09823},
  archiveprefix = {arXiv},
  primaryclass  = {cs.DS},
  url           = {https://arxiv.org/abs/1806.09823}
}

@misc{ANN-limits,
  title         = {Worst-case Performance of Popular Approximate Nearest Neighbor Search Implementations: Guarantees and Limitations},
  author        = {Piotr Indyk and Haike Xu},
  year          = {2023},
  eprint        = {2310.19126},
  archiveprefix = {arXiv},
  primaryclass  = {cs.DS},
  url           = {https://arxiv.org/abs/2310.19126}
}

@misc{few-shot,
  title         = {Language Models are Few-Shot Learners},
  author        = {Tom B. Brown and Benjamin Mann and Nick Ryder and Melanie Subbiah and Jared Kaplan and Prafulla Dhariwal and Arvind Neelakantan and Pranav Shyam and Girish Sastry and Amanda Askell and Sandhini Agarwal and Ariel Herbert-Voss and Gretchen Krueger and Tom Henighan and Rewon Child and Aditya Ramesh and Daniel M. Ziegler and Jeffrey Wu and Clemens Winter and Christopher Hesse and Mark Chen and Eric Sigler and Mateusz Litwin and Scott Gray and Benjamin Chess and Jack Clark and Christopher Berner and Sam McCandlish and Alec Radford and Ilya Sutskever and Dario Amodei},
  year          = {2020},
  eprint        = {2005.14165},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/2005.14165}
}

@inproceedings{BinClone,
  author    = {Farhadi, Mohammad Reza and Fung, Benjamin C.M. and Charland, Philippe and Debbabi, Mourad},
  booktitle = {2014 Eighth International Conference on Software Security and Reliability (SERE)},
  title     = {BinClone: Detecting Code Clones in Malware},
  year      = {2014},
  volume    = {},
  number    = {},
  pages     = {78-87},
  keywords  = {Cloning;Assembly;Malware;Feature extraction;Vectors;Registers;Detectors;Assembly Code Clone Detection;Malware Analysis;Reverse Engineering;Binary Analysis},
  doi       = {10.1109/SERE.2014.21}
}

@inproceedings{blanket-exec,
  author    = {Manuel Egele and Maverick Woo and Peter Chapman and David Brumley},
  title     = {Blanket Execution: Dynamic Similarity Testing for Program Binaries and Components},
  booktitle = {23rd USENIX Security Symposium (USENIX Security 14)},
  year      = {2014},
  isbn      = {978-1-931971-15-7},
  address   = {San Diego, CA},
  pages     = {303-317},
  url       = {https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/egele},
  publisher = {USENIX Association},
  month     = aug
}

@inproceedings{Kam1n0,
  author    = {Ding, Steven H.H. and Fung, Benjamin C.M. and Charland, Philippe},
  title     = {Kam1n0: MapReduce-based Assembly Clone Search for Reverse Engineering},
  year      = {2016},
  isbn      = {9781450342322},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2939672.2939719},
  doi       = {10.1145/2939672.2939719},
  abstract  = {Assembly code analysis is one of the critical processes for detecting and proving software plagiarism and software patent infringements when the source code is unavailable. It is also a common practice to discover exploits and vulnerabilities in existing software. However, it is a manually intensive and time-consuming process even for experienced reverse engineers. An effective and efficient assembly code clone search engine can greatly reduce the effort of this process, since it can identify the cloned parts that have been previously analyzed. The assembly code clone search problem belongs to the field of software engineering. However, it strongly depends on practical nearest neighbor search techniques in data mining and databases. By closely collaborating with reverse engineers and Defence Research and Development Canada (DRDC), we study the concerns and challenges that make existing assembly code clone approaches not practically applicable from the perspective of data mining. We propose a new variant of LSH scheme and incorporate it with graph matching to address these challenges. We implement an integrated assembly clone search engine called Kam1n0. It is the first clone search engine that can efficiently identify the given query assembly function's subgraph clones from a large assembly code repository. Kam1n0 is built upon the Apache Spark computation framework and Cassandra-like key-value distributed storage. A deployed demo system is publicly available. Extensive experimental results suggest that Kam1n0 is accurate, efficient, and scalable for handling large volume of assembly code.},
  booktitle = {Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining},
  pages     = {461–470},
  numpages  = {10},
  keywords  = {assembly clone search, information retrieval, mining software repositorie},
  location  = {San Francisco, California, USA},
  series    = {KDD '16}
}

@misc{scaling-laws,
  title         = {Scaling Laws for Neural Language Models},
  author        = {Jared Kaplan and Sam McCandlish and Tom Henighan and Tom B. Brown and Benjamin Chess and Rewon Child and Scott Gray and Alec Radford and Jeffrey Wu and Dario Amodei},
  year          = {2020},
  eprint        = {2001.08361},
  archiveprefix = {arXiv},
  primaryclass  = {cs.LG},
  url           = {https://arxiv.org/abs/2001.08361}
}

@inproceedings{patch,
  author    = {Xu, Zhengzi and Chen, Bihuan and Chandramohan, Mahinthan and Liu, Yang and Song, Fu},
  booktitle = {2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)},
  title     = {SPAIN: Security Patch Analysis for Binaries towards Understanding the Pain and Pills},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {462-472},
  keywords  = {Security;Semantics;Software;Tools;Scalability;Registers;Portable document format},
  doi       = {10.1109/ICSE.2017.49}
}

@misc{qwen2,
  title         = {Qwen2.5-Coder Technical Report},
  author        = {Binyuan Hui and Jian Yang and Zeyu Cui and Jiaxi Yang and Dayiheng Liu and Lei Zhang and Tianyu Liu and Jiajun Zhang and Bowen Yu and Keming Lu and Kai Dang and Yang Fan and Yichang Zhang and An Yang and Rui Men and Fei Huang and Bo Zheng and Yibo Miao and Shanghaoran Quan and Yunlong Feng and Xingzhang Ren and Xuancheng Ren and Jingren Zhou and Junyang Lin},
  year          = {2024},
  eprint        = {2409.12186},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/2409.12186}
}

@misc{qwen3,
  title         = {Qwen3 Technical Report},
  author        = {Qwen Team},
  year          = {2025},
  eprint        = {2505.09388},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/2505.09388}
}

@misc{gemma3,
  title         = {Gemma 3 Technical Report},
  author        = {Google Team},
  year          = {2025},
  eprint        = {2503.19786},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/2503.19786}
}

@misc{gemini2.5,
  title         = {Gemini 2.5: Pushing the Frontier with Advanced Reasoning, Multimodality, Long Context, and Next Generation Agentic Capabilities},
  author        = {Google Team},
  year          = {2025},
  eprint        = {2507.06261},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/2507.06261}
}

@misc{gpt4,
  title         = {GPT-4 Technical Report},
  author        = {OpenAI},
  year          = {2024},
  eprint        = {2303.08774},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CL},
  url           = {https://arxiv.org/abs/2303.08774}
}

@misc{ghidra,
  author  = {National Security Agency},
  title   = {Ghidra Software Reverse Engineering Framework},
  url     = {https://github.com/NationalSecurityAgency/ghidra},
  version = {11.4.1},
  year    = {2025-07-31}
}

@misc{ida,
  author  = {hex-rays},
  title   = {IDA Pro},
  url     = {https://hex-rays.com/ida-pro},
  version = {9.1},
  year    = {2025-02-28}
}

@book{c++11,
  added-at  = {2012-10-08T01:13:47.000+0200},
  address   = {Geneva, Switzerland},
  author    = {{ISO}},
  bibdate   = {Mon Dec 19 11:12:12 2011},
  bibsource = {http://www.math.utah.edu/pub/tex/bib/isostd.bib},
  biburl    = {https://www.bibsonomy.org/bibtex/24b660c16d9a5ab0ad595b1555402c797/gron},
  day       = 28,
  interhash = {ff5df6d7fa67f89d7d5ea964dab3e3c9},
  intrahash = {4b660c16d9a5ab0ad595b1555402c797},
  keywords  = {C++ Specification Standard},
  month     = feb,
  pages     = {1338 (est.)},
  publisher = {International Organization for Standardization},
  remark    = {Revises ISO/IEC 14882:2003.},
  timestamp = {2012-10-08T01:13:47.000+0200},
  title     = {{ISO/IEC 14882:2011 Information technology --- Programming languages --- C++}},
  url       = {http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=50372},
  year      = 2012
}

@inproceedings{code-not-lang,
  author    = {Haojie He and Xingwei Lin and Ziang Weng and Ruijie Zhao and Shuitao Gan and Libo Chen and Yuede Ji and Jiashui Wang and Zhi Xue},
  title     = {Code is not Natural Language: Unlock the Power of {Semantics-Oriented} Graph Representation for Binary Code Similarity Detection},
  booktitle = {33rd USENIX Security Symposium (USENIX Security 24)},
  year      = {2024},
  isbn      = {978-1-939133-44-1},
  address   = {Philadelphia, PA},
  pages     = {1759--1776},
  url       = {https://www.usenix.org/conference/usenixsecurity24/presentation/he-haojie},
  publisher = {USENIX Association},
  month     = aug
}

@inproceedings{deprio,
  author    = {Jialai Wang and Chao Zhang and Longfei Chen and Yi Rong and Yuxiao Wu and Hao Wang and Wende Tan and Qi Li and Zongpeng Li},
  title     = {Improving {ML-based} Binary Function Similarity Detection by Assessing and Deprioritizing Control Flow Graph Features},
  booktitle = {33rd USENIX Security Symposium (USENIX Security 24)},
  year      = {2024},
  isbn      = {978-1-939133-44-1},
  address   = {Philadelphia, PA},
  pages     = {4265--4282},
  url       = {https://www.usenix.org/conference/usenixsecurity24/presentation/wang-jialai},
  publisher = {USENIX Association},
  month     = aug
}

@inproceedings{jtrans,
  author    = {Wang, Hao and Qu, Wenjie and Katz, Gilad and Zhu, Wenyu and Gao, Zeyu and Qiu, Han and Zhuge, Jianwei and Zhang, Chao},
  title     = {jTrans: jump-aware transformer for binary code similarity detection},
  year      = {2022},
  isbn      = {9781450393799},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3533767.3534367},
  doi       = {10.1145/3533767.3534367},
  abstract  = {Binary code similarity detection (BCSD) has important applications in various fields such as vulnerabilities detection, software component analysis, and reverse engineering. Recent studies have shown that deep neural networks (DNNs) can comprehend instructions or control-flow graphs (CFG) of binary code and support BCSD. In this study, we propose a novel Transformer-based approach, namely jTrans, to learn representations of binary code. It is the first solution that embeds control flow information of binary code into Transformer-based language models, by using a novel jump-aware representation of the analyzed binaries and a newly-designed pre-training task. Additionally, we release to the community a newly-created large dataset of binaries, BinaryCorp, which is the most diverse to date. Evaluation results show that jTrans outperforms state-of-the-art (SOTA) approaches on this more challenging dataset by 30.5\% (i.e., from 32.0\% to 62.5\%). In a real-world task of known vulnerability searching, jTrans achieves a recall that is 2X higher than existing SOTA baselines.},
  booktitle = {Proceedings of the 31st ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages     = {1–13},
  numpages  = {13},
  keywords  = {Similarity Detection, Neural Networks, Datasets, Binary Analysis},
  location  = {Virtual, South Korea},
  series    = {ISSTA 2022}
}


@article{UniASM,
  title    = {UniASM: Binary code similarity detection without fine-tuning},
  journal  = {Neurocomputing},
  volume   = {630},
  pages    = {129646},
  year     = {2025},
  issn     = {0925-2312},
  doi      = {https://doi.org/10.1016/j.neucom.2025.129646},
  url      = {https://www.sciencedirect.com/science/article/pii/S0925231225003182},
  author   = {Yeming Gu and Hui Shu and Fei Kang and Fan Hu},
  keywords = {Similarity detection, Embedding, Binary code, Assembly language, Vulnerability},
  abstract = {Binary code similarity detection (BCSD) is widely used in various binary analysis tasks such as vulnerability search, malware detection, clone detection, and patch analysis. Recent studies have shown that the learning-based binary code embedding models perform better than the traditional feature-based approaches. However, previous studies have not delved deeply into the key factors that affect model performance. In this paper, we design extensive ablation studies to explore these influencing factors. The experimental results have provided us with many new insights. We have made innovations in both code representation and model selection: we propose a novel rich-semantic function representation technique to ensure the model captures the intricate nuances of binary code, and we introduce the first UniLM-based binary code embedding model, named UniASM, which includes two newly designed training tasks to learn representations of binary functions. The experimental results show that UniASM outperforms the state-of-the-art (SOTA) approaches on the evaluation datasets. The average scores of Recall@1 on cross-compilers, cross-optimization-levels, and cross-obfuscations have improved by 12.7%, 8.5%, and 22.3%, respectively, compared to the best of the baseline methods. Besides, in the real-world task of known vulnerability search, UniASM outperforms all the current baselines.}
}

@misc{busybox,
  author  = {Vlasenko, Denys and Reutner-Fischer, Bernhard and Landley, Rob},
  title   = {BusyBox},
  url     = {https://busybox.net/},
  version = {1.37.0},
  year    = {2024-09-27}
}

@misc{coreutils,
  author  = {Deymo, Alex and Meyering, Jim and Eggert, Paul and Brady, Padraig and Voelker, Bernhard and Funk, Collin},
  title   = {Coreutils - GNU core utilities},
  url     = {https://www.gnu.org/software/coreutils/},
  version = {9.7},
  year    = {2025-04-09}
}

@misc{curl,
  author  = {Stenberg, Daniel},
  title   = {curl - command line tool and library for transferring data with URLs},
  url     = {https://curl.se/},
  version = {8.15.0},
  year    = {2025-07-16}
}

@misc{image-magick,
  author  = {Cristy, John},
  title   = {Mastering Digital Image Alchemy},
  url     = {https://imagemagick.org/},
  version = {7.1.2},
  year    = {2025-07-13}
}

@misc{openssl,
  author  = {Cox, Mark and Engelschall, Ralf and Henson, Stephen and Laurie, Ben and Sutton, Paul},
  title   = {OpenSSL},
  url     = {https://www.openssl.org/},
  version = {3.5.2},
  year    = {2025-08-05}
}

@misc{putty,
  author  = {Tatham, Simon},
  title   = {PuTTY},
  url     = {https://www.chiark.greenend.org.uk/~sgtatham/putty/},
  version = {0.83},
  year    = {2025-02-08}
}

@misc{sqlite,
  author  = {D. Richard Hipp},
  title   = {SQLite},
  url     = {https://sqlite.org/},
  version = {3.50.4},
  year    = {2025-07-30}
}

@inproceedings{cisco,
  author    = {Andrea Marcelli and Mariano Graziano and Xabier Ugarte-Pedrero and Yanick Fratantonio and Mohamad Mansouri and Davide Balzarotti},
  title     = {How Machine Learning Is Solving the Binary Function Similarity Problem},
  booktitle = {31st USENIX Security Symposium (USENIX Security 22)},
  year      = {2022},
  isbn      = {978-1-939133-31-1},
  address   = {Boston, MA},
  pages     = {2099--2116},
  url       = {https://www.usenix.org/conference/usenixsecurity22/presentation/marcelli},
  publisher = {USENIX Association},
  month     = aug
}

@inproceedings{llm4decompile,
  title     = {{LLM}4{D}ecompile: Decompiling Binary Code with Large Language Models},
  author    = {Tan, Hanzhuo  and
               Luo, Qi  and
               Li, Jing  and
               Zhang, Yuqun},
  editor    = {Al-Onaizan, Yaser  and
               Bansal, Mohit  and
               Chen, Yun-Nung},
  booktitle = {Proceedings of the 2024 Conference on Empirical Methods in Natural Language Processing},
  month     = nov,
  year      = {2024},
  address   = {Miami, Florida, USA},
  publisher = {Association for Computational Linguistics},
  url       = {https://aclanthology.org/2024.emnlp-main.203/},
  doi       = {10.18653/v1/2024.emnlp-main.203},
  pages     = {3473--3487},
  abstract  = {Decompilation aims to convert binary code to high-level source code, but traditional tools like Ghidra often produce results that are difficult to read and execute. Motivated by the advancements in Large Language Models (LLMs), we propose LLM4Decompile, the first and largest open-source LLM series (1.3B to 33B) trained to decompile binary code. We optimize the LLM training process and introduce the LLM4Decompile-End models to decompile binary directly. The resulting models significantly outperform GPT-4o and Ghidra on the HumanEval and ExeBench benchmarks by over 100{\%} in terms of re-executability rate. Additionally, we improve the standard refinement approach to fine-tune the LLM4Decompile-Ref models, enabling them to effectively refine the decompiled code from Ghidra and achieve a further 16.2{\%} improvement over the LLM4Decompile-End. LLM4Decompile demonstrates the potential of LLMs to revolutionize binary code decompilation, delivering remarkable improvements in readability and executability while complementing conventional tools for optimal results.}
}

@inproceedings{source-analysis,
  author    = {Chongzhou Fang and Ning Miao and Shaurya Srivastav and Jialin Liu and Ruoyu Zhang and Ruijie Fang and Asmita and Ryan Tsang and Najmeh Nazari and Han Wang and Houman Homayoun},
  title     = {Large Language Models for Code Analysis: Do {LLMs} Really Do Their Job?},
  booktitle = {33rd USENIX Security Symposium (USENIX Security 24)},
  year      = {2024},
  isbn      = {978-1-939133-44-1},
  address   = {Philadelphia, PA},
  pages     = {829--846},
  url       = {https://www.usenix.org/conference/usenixsecurity24/presentation/fang},
  publisher = {USENIX Association},
  month     = aug
}

@misc{funcVul,
  title         = {FuncVul: An Effective Function Level Vulnerability Detection Model using LLM and Code Chunk},
  author        = {Sajal Halder and Muhammad Ejaz Ahmed and Seyit Camtepe},
  year          = {2025},
  eprint        = {2506.19453},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CR},
  url           = {https://arxiv.org/abs/2506.19453}
}

@inproceedings{llm-fuzz,
  author    = {Asmita and Yaroslav Oliinyk and Michael Scott and Ryan Tsang and Chongzhou Fang and Houman Homayoun},
  title     = {Fuzzing {BusyBox}: Leveraging {LLM} and Crash Reuse for Embedded Bug Unearthing},
  booktitle = {33rd USENIX Security Symposium (USENIX Security 24)},
  year      = {2024},
  isbn      = {978-1-939133-44-1},
  address   = {Philadelphia, PA},
  pages     = {883--900},
  url       = {https://www.usenix.org/conference/usenixsecurity24/presentation/asmita},
  publisher = {USENIX Association},
  month     = aug
}

@inproceedings{distillation,
  author    = {Buciluundefined, Cristian and Caruana, Rich and Niculescu-Mizil, Alexandru},
  title     = {Model compression},
  year      = {2006},
  isbn      = {1595933395},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1150402.1150464},
  doi       = {10.1145/1150402.1150464},
  abstract  = {Often the best performing supervised learning models are ensembles of hundreds or thousands of base-level classifiers. Unfortunately, the space required to store this many classifiers, and the time required to execute them at run-time, prohibits their use in applications where test sets are large (e.g. Google), where storage space is at a premium (e.g. PDAs), and where computational power is limited (e.g. hea-ring aids). We present a method for "compressing" large, complex ensembles into smaller, faster models, usually without significant loss in performance.},
  booktitle = {Proceedings of the 12th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining},
  pages     = {535–541},
  numpages  = {7},
  keywords  = {supervised learning, model compression},
  location  = {Philadelphia, PA, USA},
  series    = {KDD '06}
}

@article{VexIR2Vec,
  author    = {VenkataKeerthy, S. and Banerjee, Soumya and Dey, Sayan and Andaluri, Yashas and PS, Raghul and Kalyanasundaram, Subrahmanyam and Pereira, Fernando Magno Quint\~{a}o and Upadrasta, Ramakrishna},
  title     = {VexIR2Vec: An Architecture-Neutral Embedding Framework for Binary Similarity},
  year      = {2025},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  issn      = {1049-331X},
  url       = {https://doi.org/10.1145/3721481},
  doi       = {10.1145/3721481},
  abstract  = {Binary similarity involves determining whether two binary programs exhibit similar functionality with applications in vulnerability detection, malware analysis, and copyright detection. However, variations in compiler settings, target architectures, and deliberate code obfuscations significantly complicate the similarity measurement by effectively altering the syntax, semantics, and structure of the underlying binary. To address these challenges, we propose VexIR2Vec, a robust, architecture-neutral approach based on VEX-IR to solve binary similarity tasks. VexIR2Vec consists of three key components: a peephole extractor, a normalization engine (VexINE), and an embedding model (VexNet). The process to build program embeddings starts with the extraction of sequences of basic blocks, or peepholes, from control-flow graphs via random walks, capturing structural information. These generated peepholes are then normalized using VexINE, which applies compiler-inspired transformations to reduce architectural and compiler-induced variations. Embeddings of peepholes are generated using representation learning techniques, avoiding Out-Of-Vocabulary (OOV) issues. These embeddings are then fine-tuned with VexNet, a feed-forward Siamese network that maps functions into a high dimensional space for diffing and searching tasks in an application-independent manner.We evaluate VexIR2Vec against five baselines — BinDiff, DeepBinDiff, SAFE, BinFinder, and histograms of opcodes — on a dataset comprising  (2.7M)  functions and  (15.5K)  binaries from  (7)  projects compiled across  (12)  compilers targeting x86 and ARM architectures. The experiments span four adversarial settings — cross-optimization, cross-compilation, cross-architecture, and obfuscations — that are typically exploited by malware and vulnerabilities. In diffing experiments, VexIR2Vec outperforms the nearest baseline in these four scenarios by  (40\%) ,  (18\%) ,  (21\%) , and  (60\%) , respectively. In the searching experiment, VexIR2Vec achieves a mean average precision of  (0.76) , the nearest baseline, by  (46\%) . Our framework is highly scalable and is built as a lightweight, multi-threaded, parallel library using only open-source tools. VexIR2Vec is  (approx 3.1) – (3.5times) faster than the closest baselines and orders-of-magnitude faster than other tools.},
  note      = {Just Accepted},
  journal   = {ACM Trans. Softw. Eng. Methodol.},
  month     = mar,
  keywords  = {Binary Similarity, Program Embedding, Representation Learning}
}

@misc{llvmir1,
  title         = {Cross-Language Binary-Source Code Matching with Intermediate Representations},
  author        = {Yi Gui and Yao Wan and Hongyu Zhang and Huifang Huang and Yulei Sui and Guandong Xu and Zhiyuan Shao and Hai Jin},
  year          = {2022},
  eprint        = {2201.07420},
  archiveprefix = {arXiv},
  primaryclass  = {cs.SE},
  url           = {https://arxiv.org/abs/2201.07420}
}

@inproceedings{llvmir2,
  author    = {Zhang, Zhongtang and Liu, Shengli and Yang, Qichao and Guo, Shichen},
  booktitle = {2021 IEEE 4th Advanced Information Management, Communicates, Electronic and Automation Control Conference (IMCEC)},
  title     = {Semantic Understanding of Source and Binary Code based on Natural Language Processing},
  year      = {2021},
  volume    = {4},
  number    = {},
  pages     = {2010-2016},
  keywords  = {Training;Semantics;Process control;Binary codes;Transforms;Syntactics;Natural language processing;Source code;binary code;LLVM IR;semantic understanding;natural language processing},
  doi       = {10.1109/IMCEC51613.2021.9482032}
}

@inproceedings{llvmir3,
  author    = {Feng, Qian and Wang, Minghua and Zhang, Mu and Zhou, Rundong and Henderson, Andrew and Yin, Heng},
  title     = {Extracting Conditional Formulas for Cross-Platform Bug Search},
  year      = {2017},
  isbn      = {9781450349444},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3052973.3052995},
  doi       = {10.1145/3052973.3052995},
  abstract  = {With the recent increase in security breaches in embedded systems and IoT devices, it becomes increasingly important to search for vulnerabilities directly in binary executables in a cross-platform setting. However, very little has been explored in this domain. The existing efforts are prone to producing considerable false positives, and their results cannot provide explainable evidence for human analysts to eliminate these false positives. In this paper, we propose to extract conditional formulas as higher-level semantic features from the raw binary code to conduct the code search. A conditional formula explicitly captures two cardinal factors of a bug: 1) erroneous data dependencies and 2) missing or invalid condition checks. As a result, binary code search on conditional formulas produces significantly higher accuracy and provide meaningful evidence for human analysts to further examine the search results. We have implemented a prototype, XMATCH, and evaluated it using well-known software, including OpenSSL and BusyBox. Experimental results have shown that XMATCH outperforms the existing bug search techniques in terms of accuracy. Moreover, by evaluating 5 recent vulnerabilities, XMATCH provides clear evidence for human analysts to determine if a matched candidate is indeed vulnerable or has been patched.},
  booktitle = {Proceedings of the 2017 ACM on Asia Conference on Computer and Communications Security},
  pages     = {346–359},
  numpages  = {14},
  keywords  = {binary analysis, firmware security, vulnerability search},
  location  = {Abu Dhabi, United Arab Emirates},
  series    = {ASIA CCS '17}
}

@inproceedings{zeek,
  author    = {Shalev, Noam and Partush, Nimrod},
  title     = {Binary Similarity Detection Using Machine Learning},
  year      = {2018},
  isbn      = {9781450359931},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3264820.3264821},
  doi       = {10.1145/3264820.3264821},
  abstract  = {Finding similar procedures in stripped binaries has various use cases in the domains of cyber security and intellectual property. Previous works have attended this problem and came up with approaches that either trade throughput for accuracy or address a more relaxed problem.In this paper, we present a cross-compiler-and-architecture approach for detecting similarity between binary procedures, which achieves both high accuracy and peerless throughput. For this purpose, we employ machine learning alongside similarity by composition: we decompose the code into smaller comparable fragments, transform these fragments to vectors, and build machine learning-based predictors for detecting similarity between vectors that originate from similar procedures.We implement our approach in a tool called Zeek and evaluate it by searching similarities in open source projects that we crawl from the world-wide-web. Our results show that we perform 250X faster than state-of-the-art tools without harming accuracy.},
  booktitle = {Proceedings of the 13th Workshop on Programming Languages and Analysis for Security},
  pages     = {42–47},
  numpages  = {6},
  keywords  = {binary similarity, proc2vec},
  location  = {Toronto, Canada},
  series    = {PLAS '18}
}

@inproceedings{malware-id,
  author    = {Jilcott, Steven},
  booktitle = {2015 IEEE International Symposium on Technologies for Homeland Security (HST)},
  title     = {Scalable malware forensics using phylogenetic analysis},
  year      = {2015},
  volume    = {},
  number    = {},
  pages     = {1-6},
  keywords  = {Phylogeny;Acceleration;Irrigation;Pipelines;formatting;style;styling;insert},
  doi       = {10.1109/THS.2015.7225311}
}

@inproceedings{malware-id2,
  author    = {Qi, Panpan and Zhang, Zhaoqi and Wang, Wei and Yao, Chang},
  booktitle = {2020 25th International Conference on Pattern Recognition (ICPR)},
  title     = {Malware Detection by Exploiting Deep Learning over Binary Programs},
  year      = {2021},
  volume    = {},
  number    = {},
  pages     = {9068-9075},
  keywords  = {Deep learning;Analytical models;Computer hacking;Feature extraction;Malware;Data models;Pattern recognition},
  doi       = {10.1109/ICPR48806.2021.9412227}
}

@inproceedings{malware-id3,
  author    = {Wu, Cangshuai and Shi, Jiangyong and Yang, Yuexiang and Li, Wenhua},
  title     = {Enhancing Machine Learning Based Malware Detection Model by Reinforcement Learning},
  year      = {2018},
  isbn      = {9781450365673},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3290480.3290494},
  doi       = {10.1145/3290480.3290494},
  abstract  = {Malware detection is getting more and more attention due to the rapid growth of new malware. As a result, machine learning (ML) has become a popular way to detect malware variants. However, machine learning models can also be cheated. Through reinforcement learning (RL), we can generate new malware samples which can bypass the detection of machine learning. In this paper, a RL model on malware generation named gym-plus is designed. Gym-plus is built based on gym-malware with some improvements. As a result, the probability of evading machine learning based static PE malware detection models is increased by 30\%. Based on these newly generated samples, we retrain our detecting model to detect unknown threats. In our test, the detection accuracy of malware increased from 15.75\% to 93.5\%.},
  booktitle = {Proceedings of the 8th International Conference on Communication and Network Security},
  pages     = {74–78},
  numpages  = {5},
  keywords  = {static analysis, reinforcement learning, malware evasion, machine learning},
  location  = {Qingdao, China},
  series    = {ICCNS '18}
}

@inproceedings{malware-id4,
  author    = {Edward Raff and
               Jon Barker and
               Jared Sylvester and
               Robert Brandon and
               Bryan Catanzaro and
               Charles K. Nicholas},
  title     = {Malware Detection by Eating a Whole {EXE}},
  booktitle = {The Workshops of the The Thirty-Second {AAAI} Conference on Artificial
               Intelligence, New Orleans, Louisiana, USA, February 2-7, 2018},
  series    = {{AAAI} Technical Report},
  volume    = {{WS-18}},
  pages     = {268--276},
  publisher = {{AAAI} Press},
  year      = {2018},
  url       = {https://aaai.org/ocs/index.php/WS/AAAIW18/paper/view/16422},
  timestamp = {Mon, 04 Sep 2023 16:57:01 +0200},
  biburl    = {https://dblp.org/rec/conf/aaai/RaffBSBCN18.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{precise-static-vuln,
  author     = {David, Yaniv and Partush, Nimrod and Yahav, Eran},
  title      = {FirmUp: Precise Static Detection of Common Vulnerabilities in Firmware},
  year       = {2018},
  issue_date = {February 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {53},
  number     = {2},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/3296957.3177157},
  doi        = {10.1145/3296957.3177157},
  abstract   = {We present a static, precise, and scalable technique for finding CVEs (Common Vulnerabilities and Exposures) in stripped firmware images. Our technique is able to efficiently find vulnerabilities in real-world firmware with high accuracy. Given a vulnerable procedure in an executable binary and a firmware image containing multiple stripped binaries, our goal is to detect possible occurrences of the vulnerable procedure in the firmware image. Due to the variety of architectures and unique tool chains used by vendors, as well as the highly customized nature of firmware, identifying procedures in stripped firmware is extremely challenging. Vulnerability detection requires not only pairwise similarity between procedures but also information about the relationships between procedures in the surrounding executable. This observation serves as the foundation for a novel technique that establishes a partial correspondence between procedures in the two binaries. We implemented our technique in a tool called FirmUp and performed an extensive evaluation over 40 million procedures, over 4 different prevalent architectures, crawled from public vendor firmware images. We discovered 373 vulnerabilities affecting publicly available firmware, 147 of them in the latest available firmware version for the device. A thorough comparison of FirmUp to previous methods shows that it accurately and effectively finds vulnerabilities in firmware, while outperforming the detection rate of the state of the art by 45\% on average.},
  journal    = {SIGPLAN Not.},
  month      = mar,
  pages      = {392–404},
  numpages   = {13},
  keywords   = {partial equivalence, static binary analysis, statistical similarity, verification-aided similarity}
}

@article{firmware-vuln,
  author   = {Li, Qiang and Tan, Dawei and Ge, Xin and Wang, Haining and Li, Zhi and Liu, Jiqiang},
  journal  = {IEEE Transactions on Dependable and Secure Computing},
  title    = {Understanding Security Risks of Embedded Devices Through Fine-Grained Firmware Fingerprinting},
  year     = {2022},
  volume   = {19},
  number   = {6},
  pages    = {4099-4112},
  keywords = {Security;Internet;Microprogramming;Blogs;Performance evaluation;Fingerprint recognition;Software;Firmware;fingerprinting;embedded device;vulnerability},
  doi      = {10.1109/TDSC.2021.3119970}
}

@inproceedings{ERS0,
  author    = {Max Beninger and
               Philippe Charland and
               Steven H. H. Ding and
               Benjamin C. M. Fung},
  editor    = {Claire Kwan and
               Lauri Lindstr{\"{o}}m and
               Davide Giovannelli and
               Karlis Podins and
               Damjan Strucl},
  title     = {{ERS0:} Enhancing Military Cybersecurity with AI-Driven {SBOM} for
               Firmware Vulnerability Detection and Asset Management},
  booktitle = {16th International Conference on Cyber Conflict: Over the Horizon,
               CyCon 2024, Tallinn, Estonia, May 28-31, 2024},
  pages     = {141--160},
  publisher = {{IEEE}},
  year      = {2024},
  url       = {https://doi.org/10.23919/CyCon62501.2024.10685598},
  doi       = {10.23919/CYCON62501.2024.10685598},
  timestamp = {Thu, 17 Oct 2024 16:11:28 +0200},
  biburl    = {https://dblp.org/rec/conf/cycon/BeningerCDF24.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{sbom-difficulty,
  author     = {Bi, Tingting and Xia, Boming and Xing, Zhenchang and Lu, Qinghua and Zhu, Liming},
  title      = {On the Way to SBOMs: Investigating Design Issues and Solutions in Practice},
  year       = {2024},
  issue_date = {July 2024},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {33},
  number     = {6},
  issn       = {1049-331X},
  url        = {https://doi.org/10.1145/3654442},
  doi        = {10.1145/3654442},
  abstract   = {The increase of software supply chain threats has underscored the necessity for robust security mechanisms, among which the Software Bill of Materials (SBOM) stands out as a promising solution. SBOMs, by providing a machine-readable inventory of software composition details, play a crucial role in enhancing transparency and traceability within software supply chains. This empirical study delves into the practical challenges and solutions associated with the adoption of SBOMs through an analysis of 4,786 GitHub discussions across 510 SBOM-related projects. Through repository mining and analysis, this research delineates key topics, challenges, and solutions intrinsic to the effective utilization of SBOMs. Furthermore, we shed light on commonly used tools and frameworks for SBOM generation, exploring their respective strengths and limitations. This study underscores a set of findings, for example, there are four phases of the SBOM life cycle, and each phase has a set of SBOM development activities and issues; in addition, this study emphasizes the role SBOM play in ensuring resilient software development practices and the imperative of their widespread adoption and integration to bolster supply chain security. The insights of our study provide vital input for future work and practical advancements in this topic.},
  journal    = {ACM Trans. Softw. Eng. Methodol.},
  month      = jun,
  articleno  = {149},
  numpages   = {25},
  keywords   = {Software supply chain, software bill of materials, SBOM, empirical study, mining software repository}
}